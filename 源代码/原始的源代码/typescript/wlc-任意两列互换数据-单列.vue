<template>
    <div class="吴乐川-任意两列互换数据-单列" :class="本列之特征样式类名之配置" @click="每当根元素点击后($event)">
        <header class="列首">
            <div class="列标题栏">
                <slot name="界面皿-标题栏">
                    <div class="列标题栏之默认内容">
                        <h5>{{ 本列之标题栏之文字 }}</h5>
                    </div>
                </slot>
            </div>

            <div class="功能块-条目过滤器">
                <input
                    v-model="用以过滤条目之关键词"
                    :placeholder="条目过滤器之文本输入框之空框状态提示措辞"
                    class="条目过滤器-文本输入框"
                    :class="条目过滤器文本输入框元素之样式类名配置"
                    :disabled="应全面禁止交互 || 所有未禁止交互之条目之列表.length < 1"
                    @keydown.stop
                    @keyup.stop
                    @keypress.stop
                />
            </div>

            <div class="功能块-全选或全部取消选中">
                <label
                    class="包裹着输入项 包裹着输入项-勾选项"
                    :class="与选中所有条目_含隐藏之条目_之交互相关的汇总数据.交互项之特征样式类名_其根元素"
                >
                    <span
                        class="输入项 输入项-勾选项"
                        :class="与选中所有条目_含隐藏之条目_之交互相关的汇总数据.交互项之特征样式类名_其勾选项之根元素"
                    >
                        <span class="勾选项视觉假体"></span>
                        <input
                            type="checkbox"
                            :checked="与选中所有条目_含隐藏之条目_之交互相关的汇总数据.三态勾选项之状态值 === '已勾选'"
                            :disabled="应全面禁止交互 || 与选中所有条目_含隐藏之条目_之交互相关的汇总数据.应禁止交互"
                            @change="每当选择所有条目或清除所有条目之选中状态_含隐藏之条目_之交互项动作时($event)"
                        />
                    </span>

                    <span class="输入项配文 输入项配文-勾选项">{{ 与选中所有条目_含隐藏之条目_之交互相关的汇总数据.交互项之界面措辞 }}</span>
                </label>

                <label
                    class="包裹着输入项 包裹着输入项-勾选项"
                    :class="与选中所有条目_仅列示之条目_之交互相关的汇总数据.交互项之特征样式类名_其根元素"
                >
                    <span
                        class="输入项 输入项-勾选项"
                        :class="与选中所有条目_仅列示之条目_之交互相关的汇总数据.交互项之特征样式类名_其勾选项之根元素"
                    >
                        <span class="勾选项视觉假体" ></span>
                        <input
                            type="checkbox"
                            :checked="与选中所有条目_仅列示之条目_之交互相关的汇总数据.三态勾选框之状态值 === '已勾选'"
                            :disabled="应全面禁止交互 || 与选中所有条目_仅列示之条目_之交互相关的汇总数据.应禁止交互"
                            @change="每当选择所有条目或清除所有条目之选中状态_仅列示之条目_之交互项动作时($event)"
                        />
                    </span>

                    <span class="输入项配文 输入项配文-勾选项">{{ 与选中所有条目_仅列示之条目_之交互相关的汇总数据.交互项之界面措辞 }}</span>
                </label>
            </div>

            <dl class="字典式列表 功能块-条目统计">
                <div class="字典式列表之条目 字典式列表之条目--所有条目之统计">
                    <dt><span>总数</span></dt>

                    <dd>
                        <span class="值 值--总数">{{ 所有条目之总数 }}</span>

                        <span class="括弧 括弧--左">（</span>
                        <span class="值-前缀 值-前缀--列示数">已列示</span>
                        <span class="值 值--列示数">{{ 当下列示着的所有条目之列表.length }}</span>
                        <span class="括弧 括弧--右">）</span>
                    </dd>
                </div>

                <div class="字典式列表之条目 字典式列表之条目--已选中条目之统计">
                    <dt><span>已选中</span></dt>

                    <dd>
                        <span class="值 值--总数">{{ 当下已选中的所有条目_含隐藏之条目_之列表.length }}</span>

                        <span class="括弧 括弧--左">（</span>
                        <span class="值-前缀 值-前缀--列示数">已列示</span>
                        <span class="值 值--列示数">{{ 当下已选中的所有条目_仅列示的条目_之列表.length }}</span>
                        <span class="括弧 括弧--右">）</span>
                    </dd>
                </div>
            </dl>
        </header>

        <div class="功能块-条目列表皿">
            <div
                v-if="当下期望列示的条目过多故暂不列示任何条目"
                class="消息文本块 标准配色-暗 内容较简短 磨砂玻璃效果-弱 条目列表之提示语"
            >
                <div class="消息文本-可以滚动的内容皿">
                    <article>
                        <p>{{ 用以过滤条目之关键词 ? '符合筛选条件的' : '候选' }}条目太多，<span class="尽量不换行之短语">达<em class="值 值-期望列示之条目总数">{{
                            匹配当下过滤配置之所有条目之列表.length
                        }}</em>条，</span>已逾<span class="尽量不换行之短语"><em class="值 值-条目总数之限制数">{{
                            允许列示的条目数之上限_最终采纳值
                        }}</em>条</span>之限。为确保程序不致僵死，暂不列示任何条目。</p>
                        <p><strong>请输入筛选关键词以减少须列示的条目。</strong></p>
                    </article>
                </div>
            </div>

            <ol v-else class="条目列表">
                <li
                    v-for="采取内用格式之条目 in 当下列示着的所有条目之列表"
                    :key="采取内用格式之条目.唯一标识"
                    class="吴乐川-任意两列互换数据-条目皿"
                    :class="求某条目之样式类名集_其皿元素(采取内用格式之条目)"
                >
                    <component
                        :key="采取内用格式之条目.唯一标识"
                        :is="vue部件之定义_订制的主表条目_最终采纳值"
                        :条目="采取内用格式之条目"
                        class="吴乐川-任意两列互换数据-条目根"
                        :class="求某条目之样式类名集_其根元素(采取内用格式之条目)"
                        @click.native="每当点击某条目后(采取内用格式之条目, $event)"
                    ></component>
                </li>
            </ol>
        </div>

        <div v-if="!不应创建底部栏目" class="功能块-条目列表说明书-控制栏">
            <button @click.stop="每当列表操作说明书开关按钮点击时()">列表操作说明</button>
            <Wlc任意两列互换数据之单列之说明书
                v-model="应呈现列表操作说明书"
                采用的标准配色方案之名称="默认"
                采用的标准配色方案之磨砂玻璃效果之名称="默认"
            ></Wlc任意两列互换数据之单列之说明书>
        </div>
    </div>
</template>









<script lang="ts">
import { Vue, Component, Prop, Model, Watch } from 'vue-property-decorator'

import Wlc任意两列互换数据之条目视觉根之默认形态 from './wlc-任意两列互换数据-条目之视觉根-默认形态.vue'
import Wlc任意两列互换数据之单列之说明书 from './wlc-任意两列互换数据-单列之说明书.vue'

import {
    求可靠的文本,
    尽可能将用户输入的文本视为正则表达式并用以过滤列表,
} from './辅助工具集'





type 范_界面元素之样式类名之配置 = Wlc任意两列互换数据.泛范_界面元素之样式类名之配置<string>;
type 范_交互项之三态勾选框_特征样式类名 = Wlc任意两列互换数据.范_交互项之三态勾选框_特征样式类名;
type 范_三态勾选框之状态值 = Wlc任意两列互换数据.范_三态勾选框之状态值;

// type 范_基础条目 = Wlc任意两列互换数据.范_基础条目;
type 范_条目之唯一标识之列表 = Wlc任意两列互换数据.范_条目之唯一标识之列表;

type 范_内用格式之条目 = Wlc任意两列互换数据.范_内用格式之条目;
type 范_内用格式之条目之列表 = Wlc任意两列互换数据.范_内用格式之条目之列表;

type 范_各列新增条目之插入规则 = Wlc任意两列互换数据.范_各列新增条目之插入规则;
type 范_各列条目排序之函数 = Wlc任意两列互换数据.范_各列条目排序之函数;

type 范_Vue动态部件之Is属性可接受的数据 = Wlc任意两列互换数据.范_Vue动态部件之Is属性可接受的数据;

const 构建实用的条目总表_发起之原因_所有条目之列表已变动 = '所有条目之列表变动'
const 构建实用的条目总表_发起之原因_当下选中的所有条目之唯一标识之列表已变动 = '当下选中的所有条目之唯一标识之列表变动'

type 范_构建实用的条目总表_发起之原因 = (
    | '所有条目之列表变动'
    | '当下选中的所有条目之唯一标识之列表变动'
);





const 单列允许列示的条目数之上限_内部默认值 = 500

export const 各列条目排序之规则所有允许的值之列表: 范_各列新增条目之插入规则[] = [
    '总是追加在尾部',
    '总是追加在首部',
    '总是参与排序',
]





@Component({
    components: {
        Wlc任意两列互换数据之单列之说明书,
    },
})
export default class Wlc任意两列互换数据之单列 extends Vue {
    @Model('选中的条目已变动') public readonly 当下选中的所有条目之唯一标识之列表?: 范_条目之唯一标识之列表



    @Prop() public readonly 应全面禁止交互?: boolean
    @Prop() public readonly 本列之称谓?: string
    @Prop() public readonly 本列之特征样式类名之配置?: 范_界面元素之样式类名之配置
    @Prop() public readonly 允许列示的条目数之上限?: number | string
    @Prop() public readonly 所有条目之列表?: 范_内用格式之条目之列表
    @Prop() public readonly 新增条目之插入规则?: 范_各列新增条目之插入规则
    @Prop() public readonly 条目排序之函数?: 范_各列条目排序之函数
    @Prop() public readonly 本列初始的用以过滤条目之配置?: string | RegExp
    @Prop() public readonly 当下另有他列优先于本列采取视觉强调引导用户操作之?: boolean
    @Prop() public readonly 不应创建底部栏目?: boolean
    @Prop() public readonly vue部件之定义_订制的主表条目?: 范_Vue动态部件之Is属性可接受的数据





    private 用以过滤条目之关键词: string = ''
    private 所有条目之列表_最终采纳值: 范_内用格式之条目之列表 = []
    private 所有条目之列表_最终采纳值_求解之期待: null | Promise<boolean> = null
    private 所有条目之列表_最终采纳值_求解之期待之原因: string = ''
    private 三态勾选框_所有条目_含隐藏之条目_之勾选状态统计_之状态值: 范_三态勾选框之状态值 = '未勾选'
    private 三态勾选框_所有条目_仅列示之条目_之勾选状态统计_之状态值: 范_三态勾选框之状态值 = '未勾选'
    private 最末经由交互动作改变其选中之状态之条目: 范_内用格式之条目 | null = null
    private 最末经由交互动作改变其选中之状态之条目_系选中之: boolean | null = null
    private 应呈现列表操作说明书: boolean = false





    private get 应全面禁止交互_最终采纳值 (): boolean {
        return !!this.应全面禁止交互
    }

    private get 本列之称谓_最终采纳值 (): string {
        return 求可靠的文本(this.本列之称谓, '无名列', false)
    }

    private get 日志前缀 (): string {
        return `Vue 部件 <Wlc任意两列互换数据之单列> “ ${this.本列之称谓_最终采纳值} ” ：`
    }

    private get 本列之标题栏之文字 (): string {
        return this.本列之称谓_最终采纳值
    }

    private get 当下有浮层覆盖着条目列表 (): boolean {
        return !!(this.应呈现列表操作说明书)
    }

    private get 允许列示的条目数之上限_最终采纳值 (): number {
        const 外界给出值 = this.允许列示的条目数之上限

        let 拟采纳值: number = NaN
        if (typeof 外界给出值 === 'number') {
            拟采纳值 = 外界给出值
        } else if (typeof 外界给出值 === 'string' && 外界给出值.trim()) {
            拟采纳值 = +外界给出值.trim()
        }

        拟采纳值 = Math.floor(拟采纳值)

        return 拟采纳值 > 0 ? 拟采纳值 : 单列允许列示的条目数之上限_内部默认值
    }

    private get 新增条目之插入规则_最终采纳值 (): 范_各列新增条目之插入规则 {
        const 外界给出值 = this.新增条目之插入规则
        const 排序函数确已给出: boolean = typeof this.条目排序之函数 === 'function'

        let 决定采纳的值: 范_各列新增条目之插入规则
        if (typeof 外界给出值 === 'string' && 各列条目排序之规则所有允许的值之列表.includes(外界给出值)) {
            决定采纳的值 = 外界给出值
        } else {
            决定采纳的值 = 排序函数确已给出 ? '总是参与排序' : '总是追加在尾部'
        }

        return 决定采纳的值
    }

    private get 所有条目之总数 (): number {
        return this.所有条目之列表_最终采纳值.length
    }

    private get 条目过滤器之文本输入框之空框状态提示措辞 (): string {
        return this.所有未禁止交互之条目之列表.length > 0 ? '筛选条目（可用正则表达式）' : '无条目可筛选'
        // return this.所有未禁止交互之条目之列表.length > 0 ? `筛选【${this.本列之称谓_最终采纳值}】（可用正则表达式）` : '无条目可筛选'
    }

    private get 所有未禁止交互之条目之列表 (): 范_内用格式之条目之列表 {
        return this.所有条目之列表_最终采纳值.filter(条目 => !条目.已禁止选择)
    }

    private get 匹配当下过滤配置之所有条目之列表 (): 范_内用格式之条目之列表 {
        return 尽可能将用户输入的文本视为正则表达式并用以过滤列表<范_内用格式之条目>(
            this.所有条目之列表_最终采纳值,
            this.用以过滤条目之关键词,
            条目 => 条目.在界面中的称谓
        )
    }

    private get 当下列示着的所有条目之列表 (): 范_内用格式之条目之列表 {
        const 期望列示的所有条目 = this.匹配当下过滤配置之所有条目之列表
        const { 允许列示的条目数之上限_最终采纳值 } = this

        const 匹配的条目过多故暂不应列示任何条目 = 期望列示的所有条目.length > 允许列示的条目数之上限_最终采纳值
        if (匹配的条目过多故暂不应列示任何条目) {
            return []
        } else {
            return 期望列示的所有条目
        }
    }

    private get 当下列示着的所有未禁止交互之条目之列表 (): 范_内用格式之条目之列表 {
        return this.当下列示着的所有条目之列表.filter(条目 => !条目.已禁止选择)
    }

    private get 当下期望列示的条目过多故暂不列示任何条目 (): boolean {
        return this.匹配当下过滤配置之所有条目之列表.length > 0 && this.当下列示着的所有条目之列表.length === 0
    }

    private get 当下已选中的所有条目_含隐藏之条目_之列表 (): 范_内用格式之条目之列表 {
        return this.所有未禁止交互之条目之列表.filter(条目 => !!条目.已选中)
    }

    private get 当下已选中的所有条目_仅列示的条目_之列表 (): 范_内用格式之条目之列表 {
        return this.当下列示着的所有未禁止交互之条目之列表.filter(条目 => !!条目.已选中)
    }

    private get 条目过滤器文本输入框元素之样式类名配置 (): 范_界面元素之样式类名之配置 {
        const {
            当下另有他列优先于本列采取视觉强调引导用户操作之,
            当下期望列示的条目过多故暂不列示任何条目,
            用以过滤条目之关键词,
        } = this

        const 应给予视觉强调以引导用户来此: boolean = 当下期望列示的条目过多故暂不列示任何条目 && !用以过滤条目之关键词

        const 给予的视觉强调不应为动画: boolean = !!(
            应给予视觉强调以引导用户来此 &&
            当下另有他列优先于本列采取视觉强调引导用户操作之
        )

        return {
            '应给予视觉强调以引导用户来此': 应给予视觉强调以引导用户来此,
            '给予的视觉强调不应为动画': 给予的视觉强调不应为动画,
        }
    }

    private get 当下有否视觉强调动画之结论 (): boolean {
        const 结论: boolean = !!(
            this.当下期望列示的条目过多故暂不列示任何条目
        )

        return 结论
    }

    private get 与选中所有条目_含隐藏之条目_之交互相关的汇总数据 () {
        return this.求与选中所有条目之交互相关的汇总数据(true)
    }

    private get 与选中所有条目_仅列示之条目_之交互相关的汇总数据 () {
        return this.求与选中所有条目之交互相关的汇总数据(false)
    }

    private get vue部件之定义_订制的主表条目_最终采纳值 (): 范_Vue动态部件之Is属性可接受的数据 {
        const { vue部件之定义_订制的主表条目 } = this

        if (vue部件之定义_订制的主表条目 && [ 'function', 'object' ].includes(typeof vue部件之定义_订制的主表条目)) {
            return vue部件之定义_订制的主表条目
        } else {
            return Wlc任意两列互换数据之条目视觉根之默认形态
        }
    }





    @Watch('所有条目之列表', { immediate: true })
    private 每当外界给出的所有条目之列表变动后 (): void {
        this.根据外界给出的条件构建实用的条目总表(构建实用的条目总表_发起之原因_所有条目之列表已变动)
    }

    @Watch('当下选中的所有条目之唯一标识之列表', { immediate: true })
    private 每当外界给出的当下选中的所有条目之唯一标识之列表变动后 (): void {
        this.根据外界给出的条件构建实用的条目总表(构建实用的条目总表_发起之原因_当下选中的所有条目之唯一标识之列表已变动)
    }

    @Watch('当下有否视觉强调动画之结论', { immediate: true })
    private 每当外界给出的当下有否视觉强调动画之结论变动后 (结论: boolean): void {
        this.发布事件_某元素之视觉强调之状态已变动(结论)
    }





    private 根据外界给出的条件构建实用的条目总表 (本次原因: 范_构建实用的条目总表_发起之原因): Promise<boolean> {
        const { 日志前缀 } = this

        const _构建实用的条目总表 = () => {
            let 给出的所有条目之原始无序列表: 范_内用格式之条目之列表
            let 当下选中的所有条目之唯一标识之列表: 范_条目之唯一标识之列表

            if (Array.isArray(this.所有条目之列表)) {
                给出的所有条目之原始无序列表 = this.所有条目之列表
            } else {
                给出的所有条目之原始无序列表 = []
            }

            if (Array.isArray(this.当下选中的所有条目之唯一标识之列表)) {
                当下选中的所有条目之唯一标识之列表 = this.当下选中的所有条目之唯一标识之列表
            } else {
                当下选中的所有条目之唯一标识之列表 = []
            }

            const 当下选中的所有条目之唯一标识在新的所有条目列表中的存在性统计: { [某条目之唯一标识: string]: boolean } = {}

            Object.keys(当下选中的所有条目之唯一标识之列表).map(某条目之唯一标识 => {
                当下选中的所有条目之唯一标识在新的所有条目列表中的存在性统计[某条目之唯一标识] = false
            })

            const 旧有的所有条目之列表: 范_内用格式之条目之列表 = this.所有条目之列表_最终采纳值

            const 旧有的所有条目之唯一标识之列表: 范_条目之唯一标识之列表 = 旧有的所有条目之列表.map(条目 => 条目.唯一标识)
            const 给出的所有条目之唯一标识之列表: 范_条目之唯一标识之列表 = 给出的所有条目之原始无序列表.map(条目 => 条目.唯一标识)

            // const 在日志中列举条目之数量之上限 = 12; console.debug(
            //     `${日志前缀}\n\t%c正在构建新的【条目总表之最终采纳值】。%c\n\t原因：%c${本次原因}%c。`,
            //     'display: inline-block; vertical-align: baseline; color: #000; background-color: #bea; margin: 1px 2px 1px -8px; padding: 2px 0px 2px 8px; border-radius: 3px',
            //     null,
            //     'display: inline-block; vertical-align: baseline; color: #000; background-color: #edf; margin: 1px 2px; padding: 2px 4px; border-radius: 3px',
            //     null,
            //     '\n\t此时：',
            //     '\n\t\t给出的所有条目之原始无序列表：', 给出的所有条目之原始无序列表.length, '条。',
            //     给出的所有条目之原始无序列表.length === 0 ? '' : `\n\t\t\t有：${给出的所有条目之唯一标识之列表.slice(0, 在日志中列举条目之数量之上限).join('、')}${给出的所有条目之原始无序列表.length > 在日志中列举条目之数量之上限 ? '……' : '。'}`,
            //     '\n\t\t选中的所有条目之列表：', 当下选中的所有条目之唯一标识之列表.length, '条。',
            //     当下选中的所有条目之唯一标识之列表.length === 0 ? '' : `\n\t\t\t有：${当下选中的所有条目之唯一标识之列表.slice(0, 在日志中列举条目之数量之上限).join('、')}${当下选中的所有条目之唯一标识之列表.length > 在日志中列举条目之数量之上限 ? '……' : '。'}`
            // )

            let 选中的条目之列表将会变化: boolean = false

            const 应保留的旧有条目之列表: 范_内用格式之条目之列表 = 旧有的所有条目之列表.filter(条目 => {
                if (!条目) { return false }

                const {
                    唯一标识: 该条目之唯一标识,
                    已选中: 该条目原本已选中,
                    已禁止选择: 该条目已禁止选择,
                } = 条目

                const 该条目应保留: boolean = 给出的所有条目之唯一标识之列表.includes(该条目之唯一标识)

                if (该条目应保留) {
                    const 该条目此后应选中 = !该条目已禁止选择 && 当下选中的所有条目之唯一标识之列表.includes(该条目之唯一标识)
                    if (该条目原本已选中 !== 该条目此后应选中) {
                        条目.已选中 = 该条目此后应选中
                        选中的条目之列表将会变化 = true
                    }
                    if (该条目此后应选中) {
                        当下选中的所有条目之唯一标识在新的所有条目列表中的存在性统计[该条目之唯一标识] = true
                    }
                } else {
                    if (该条目原本已选中) {
                        选中的条目之列表将会变化 = true
                    }
                }

                return 该条目应保留
            })

            if (Object.keys(当下选中的所有条目之唯一标识在新的所有条目列表中的存在性统计).some(某条目之唯一标识 => !当下选中的所有条目之唯一标识在新的所有条目列表中的存在性统计[某条目之唯一标识])) {
                选中的条目之列表将会变化 = true
            }

            const 应追加至新列表的条目之列表: 范_内用格式之条目之列表 = 给出的所有条目之原始无序列表.filter(条目 => {
                if (!条目) { return false }

                const {
                    唯一标识: 该条目之唯一标识,
                } = 条目

                const 该条目应添加到新列表中去: boolean = !旧有的所有条目之唯一标识之列表.includes(该条目之唯一标识)

                if (该条目应添加到新列表中去) {
                    条目.已选中 = false
                }

                return 该条目应添加到新列表中去
            })

            const {
                新增条目之插入规则_最终采纳值,
                条目排序之函数,
            } = this

            const 给出了排序函数 = typeof 条目排序之函数 === 'function'
            const 应重新排序 = 给出了排序函数 && (新增条目之插入规则_最终采纳值 === '总是参与排序' || 旧有的所有条目之列表.length === 0)

            let 所有条目之列表_最终采纳的新值: 范_内用格式之条目之列表

            if (新增条目之插入规则_最终采纳值 === '总是追加在首部') {
                所有条目之列表_最终采纳的新值 = [
                    ...应追加至新列表的条目之列表,
                    ...应保留的旧有条目之列表,
                ]
            } else {
                所有条目之列表_最终采纳的新值 = [
                    ...应保留的旧有条目之列表,
                    ...应追加至新列表的条目之列表,
                ]
            }

            if (应重新排序) {
                所有条目之列表_最终采纳的新值.sort(条目排序之函数)
            }

            所有条目之列表_最终采纳的新值.forEach(条目 => {
                条目.唯一标识
            })

            this.所有条目之列表_最终采纳值 = 所有条目之列表_最终采纳的新值

            if (选中的条目之列表将会变化) {
                this.每当有任何条目之选中状态变动时()
            }

            return 选中的条目之列表将会变化
        }

        if (!this.所有条目之列表_最终采纳值_求解之期待) {
            const 所有条目之列表_最终采纳值_求解之期待 = new Promise<boolean>((令期待落实, 令期待落空) => {
                const 选中的条目之列表将会变化 = _构建实用的条目总表()
                this.$nextTick(() => {
                    令期待落实(选中的条目之列表将会变化)
                    this.所有条目之列表_最终采纳值_求解之期待 = null
                    this.所有条目之列表_最终采纳值_求解之期待之原因 = ''
                })
            })

            this.所有条目之列表_最终采纳值_求解之期待之原因 = 本次原因
            this.所有条目之列表_最终采纳值_求解之期待 = 所有条目之列表_最终采纳值_求解之期待
        } else {
            // console.debug(
            //     `${日志前缀}\n\t%c根据外界给出的条件构建实用的条目总表() 不执行。%c\n\t因仍在进行因%c${this.所有条目之列表_最终采纳值_求解之期待之原因}%c而起的任务。`,
            //     'display: inline-block; vertical-align: baseline; color: #000; background-color: #fdd; margin: 1px 2px 1px -8px; padding: 2px 0px 2px 8px; border-radius: 3px',
            //     null,
            //     'display: inline-block; vertical-align: baseline; color: #000; background-color: #edf; margin: 1px 2px; padding: 2px 4px; border-radius: 3px',
            //     null,
            //     '\n\t附本次原因：', 本次原因, '。'
            // )
        }

        return this.所有条目之列表_最终采纳值_求解之期待
    }

    private 求某条目之样式类名集_其皿元素 (条目: 范_内用格式之条目): 范_界面元素之样式类名之配置 {
        if (!条目) { return null }
        const 已选中 = !!条目.已选中
        const 已禁止选择 = !!条目.已禁止选择

        return {
            '已选中': 已选中,
            '已禁止选择': 已禁止选择,
            '已受迫禁止交互': this.应全面禁止交互_最终采纳值,
        }
    }

    private 求某条目之样式类名集_其根元素 (条目: 范_内用格式之条目): 范_界面元素之样式类名之配置 {
        if (!条目) { return null }

        type 范_对象形式的元素之样式类名集 = {
            [样式类名: string]: any;
        }

        const 根元素之样式类名集 = this.求某条目之样式类名集_其皿元素(条目) as 范_对象形式的元素之样式类名集

        return {
            ...根元素之样式类名集,
        }
    }

    private 求与选中所有条目之交互相关的汇总数据 (本次统计时应将暂不可见的条目一并计入?: boolean) {
        type 范_交互项之界面措辞 = (
            | '--'
            | '无可勾选项'
            | '选中所有条目（含未列示条目）'
            | '选中所有条目（仅列示条目）'
            | '清除所有选择（含未列示条目）'
            | '清除所有选择（仅列示条目）'
        );

        type 范_交互项之特征样式类名_其勾选项之根元素 = 范_交互项之三态勾选框_特征样式类名;

        let 交互项之特征样式类名_其根元素: 范_交互项之三态勾选框_特征样式类名 = null
        let 交互项之特征样式类名_其勾选项之根元素: 范_交互项之特征样式类名_其勾选项之根元素 = null

        let 交互项之界面措辞: 范_交互项之界面措辞

        const { 应全面禁止交互_最终采纳值 } = this

        const 所有参与统计之条目: 范_内用格式之条目之列表 = 本次统计时应将暂不可见的条目一并计入
            ? this.所有未禁止交互之条目之列表
            : this.当下列示着的所有未禁止交互之条目之列表

        const 三态勾选框之状态值: 范_三态勾选框之状态值 = 本次统计时应将暂不可见的条目一并计入
            ? this.三态勾选框_所有条目_含隐藏之条目_之勾选状态统计_之状态值
            : this.三态勾选框_所有条目_仅列示之条目_之勾选状态统计_之状态值

        const 界面措辞之统一后缀 = 本次统计时应将暂不可见的条目一并计入 ? '（含未列示条目）' : '（仅列示条目）'

        const { 所有条目之总数, 当下列示着的所有条目之列表 } = this
        const 所有条目均已列示: boolean = 当下列示着的所有条目之列表.length === 所有条目之总数

        const 本次参与统计的条目数为零: boolean = 所有参与统计之条目.length === 0
        const 本次统计之条目之含义并非所有条目但数目恰与总条目数相同_哪怕总条目数为零: boolean = (!本次统计时应将暂不可见的条目一并计入 && 所有条目均已列示)

        const 应禁止交互: boolean =
            应全面禁止交互_最终采纳值 ||
            本次参与统计的条目数为零 ||
            本次统计之条目之含义并非所有条目但数目恰与总条目数相同_哪怕总条目数为零

        if (应禁止交互) {
            交互项之特征样式类名_其根元素 = '已禁止交互'
            交互项之特征样式类名_其勾选项之根元素 = '已禁止交互'

            if (本次统计之条目之含义并非所有条目但数目恰与总条目数相同_哪怕总条目数为零) {
                交互项之界面措辞 = '--'
            } else {
                交互项之界面措辞 = '无可勾选项'
            }
        } else {
            if (三态勾选框之状态值 === '未勾选') {

                交互项之界面措辞 = `选中所有条目${界面措辞之统一后缀}`
                交互项之特征样式类名_其根元素 = '未勾选'
                交互项之特征样式类名_其勾选项之根元素 = '未勾选'

            } else if (三态勾选框之状态值 === '已勾选') {

                交互项之界面措辞 = `清除所有选择${界面措辞之统一后缀}`
                交互项之特征样式类名_其根元素 = '已勾选'
                交互项之特征样式类名_其勾选项之根元素 = '已勾选'

            } else {

                交互项之界面措辞 = `选中所有条目${界面措辞之统一后缀}`
                交互项之特征样式类名_其根元素 = '已部分勾选'
                交互项之特征样式类名_其勾选项之根元素 = '已部分勾选'

            }
        }

        const 汇总数据 = {
            交互项之界面措辞,
            应禁止交互,
            三态勾选框之状态值,
            交互项之特征样式类名_其根元素,
            交互项之特征样式类名_其勾选项之根元素,
        }

        // console.debug(`${this.日志前缀}\n\t含隐藏条目：`, 本次统计时应将暂不可见的条目一并计入, '\t\t状态：', 汇总数据.三态勾选框之状态值)

        return 汇总数据
    }

    private 选中或取消选中一系列列示着的条目 (本次目的是选中这一系列条目?: boolean, 条目甲?: any, 条目乙?: any): void {
        this.选中或取消选中一系列条目(this.当下列示着的所有条目之列表, 本次目的是选中这一系列条目, 条目甲, 条目乙)
    }

    private 选中或取消选中一系列条目_含隐藏之条目 (本次目的是选中这一系列条目?: boolean, 条目甲?: any, 条目乙?: any): void {
        this.选中或取消选中一系列条目(this.所有条目之列表_最终采纳值, 本次目的是选中这一系列条目, 条目甲, 条目乙)
    }

    private 选中或取消选中一系列条目 (应考察的所有条目之列表?: 范_内用格式之条目之列表, 本次目的是选中这一系列条目?: boolean, 条目甲?: any, 条目乙?: any): void {
        if (!Array.isArray(应考察的所有条目之列表)) { return }
        if (!条目甲 || !条目乙) { return }

        const 条目甲之列表编号: number = 应考察的所有条目之列表.indexOf(条目甲)
        const 条目乙之列表编号: number = 应考察的所有条目之列表.indexOf(条目乙)

        if (条目甲之列表编号 < 0 || 条目乙之列表编号 < 0 || 条目甲之列表编号 === 条目乙之列表编号) {
            return
        }

        const 起始条目之列表编号: number = Math.min(条目甲之列表编号, 条目乙之列表编号)
        const 结束条目之列表编号: number = Math.max(条目甲之列表编号, 条目乙之列表编号)

        let 条目选中之情况有变动: boolean = false
        应考察的所有条目之列表.forEach((条目, 该条目之列表编号) => {
            if (条目.已禁止选择) { return }

            const 条目原本已选中: boolean = !!条目.已选中
            const 条目参与本集体动作: boolean = 起始条目之列表编号 <= 该条目之列表编号 && 该条目之列表编号 <= 结束条目之列表编号
            if (条目参与本集体动作) {
                if (本次目的是选中这一系列条目) {
                    条目.已选中 = true
                    if (!条目原本已选中) { 条目选中之情况有变动 = true }
                } else {
                    条目.已选中 = false
                    if (条目原本已选中) { 条目选中之情况有变动 = true }
                }
            }
        })

        if (条目选中之情况有变动) {
            this.每当有任何条目之选中状态变动时()
        }
    }

    /**
     * 最终决定不厌其烦的在 4 处各自调用该动作。
     *
     * 这是因为如果改用 `@Watch('当下已选中的所有条目_含隐藏之条目_之列表')` 一值：
     * -   则某些时候当 `当下已选中的所有条目_含隐藏之条目_之列表` 变动时，其 `@Watch` 的处理程序会重复调用 2 次下列动作。而正确的行为应是仅调用一次。
     * -   另，在尝试 `@Watch` 之做法时，暂未遇到重复调用该动作“多于 2 次”之情形。
     */
    private 每当有任何条目之选中状态变动时 (): void {
        this.统计所有条目_含隐藏条目_之勾选状态()
        this.统计所有条目_仅列示条目_之勾选状态()
        this.发布事件_选中的条目已变动()
    }

    private 统计某应考察之条目之列表中的勾选状态 (所有应考察之条目: 范_内用格式之条目之列表): 范_三态勾选框之状态值 {
        const 考察的条目中已选中条目之总数: number = 所有应考察之条目.filter(条目 => 条目.已选中).length
        const 所有应考察之条目之总数: number = 所有应考察之条目.length

        let 三态勾选框之状态值: 范_三态勾选框之状态值 = '未勾选'

        if (所有应考察之条目之总数 > 0) {
            if (考察的条目中已选中条目之总数 === 所有应考察之条目之总数) {
                三态勾选框之状态值 = '已勾选'
            } else if (考察的条目中已选中条目之总数 > 0) {
                三态勾选框之状态值 = '已部分勾选'
            }
        }

        return 三态勾选框之状态值
    }

    private 统计所有条目_含隐藏条目_之勾选状态 (): void {
        this.三态勾选框_所有条目_含隐藏之条目_之勾选状态统计_之状态值 = this.统计某应考察之条目之列表中的勾选状态(this.所有未禁止交互之条目之列表)
    }

    private 统计所有条目_仅列示条目_之勾选状态 (): void {
        this.三态勾选框_所有条目_仅列示之条目_之勾选状态统计_之状态值 = this.统计某应考察之条目之列表中的勾选状态(this.当下列示着的所有未禁止交互之条目之列表)
    }





    private 发布事件_选中的条目已变动 (): void {
        const 事件之记载: 范_条目之唯一标识之列表 = this.所有条目之列表_最终采纳值
            .filter(条目 => !!条目.已选中)
            .map(条目 => 条目.唯一标识)

        this.$emit('选中的条目已变动', 事件之记载)
    }

    private 发布事件_某元素之视觉强调之状态已变动 (当下有否视觉强调动画之结论?: boolean): void {
        const 事件之记载: boolean = !!当下有否视觉强调动画之结论
        this.$emit('内部某元素之视觉强调之状态已变动', 事件之记载)
    }





    private 每当选择所有条目或清除所有条目之选中状态_含隐藏之条目_之交互项动作时 (界面表单元素变动事件之记载: InputEvent): void {
        if (!界面表单元素变动事件之记载.target) { return }
        const 界面表单元素 = 界面表单元素变动事件之记载.target as HTMLInputElement
        this.所有未禁止交互之条目之列表.forEach(条目 => { 条目.已选中 = 界面表单元素.checked })
        this.每当有任何条目之选中状态变动时()
    }

    private 每当选择所有条目或清除所有条目之选中状态_仅列示之条目_之交互项动作时 (界面表单元素变动事件之记载: InputEvent): void {
        if (!界面表单元素变动事件之记载.target) { return }
        const 界面表单元素 = 界面表单元素变动事件之记载.target as HTMLInputElement
        this.当下列示着的所有未禁止交互之条目之列表.forEach(条目 => { 条目.已选中 = 界面表单元素.checked })
        this.每当有任何条目之选中状态变动时()
    }

    private 每当根元素点击后 (事件之记载: PointerEvent): void {
        this.应呈现列表操作说明书 = false
    }

    private 每当列表操作说明书开关按钮点击时 (): void {
        this.应呈现列表操作说明书 = !this.应呈现列表操作说明书
    }

    private 每当点击某条目后 (被点击之条目: 范_内用格式之条目, 事件之记载: PointerEvent): void {
        if (this.应全面禁止交互_最终采纳值 || this.当下有浮层覆盖着条目列表) { return }

        if (被点击之条目 && 事件之记载) {
            const {
                最末经由交互动作改变其选中之状态之条目,
                最末经由交互动作改变其选中之状态之条目_系选中之,
            } = this

            const {
                shiftKey: 点击该条目时按住了_shift_键,
                ctrlKey: 点击该条目时也按住了_ctrl_键,
            } = 事件之记载

            if (!!最末经由交互动作改变其选中之状态之条目 && 点击该条目时按住了_shift_键) {
                const 序列动作之意图是选择序列中的所有条目而非取消选中它们: boolean = (最末经由交互动作改变其选中之状态之条目_系选中之 as boolean)

                if (点击该条目时也按住了_ctrl_键) {
                    this.选中或取消选中一系列条目_含隐藏之条目(
                        序列动作之意图是选择序列中的所有条目而非取消选中它们, 最末经由交互动作改变其选中之状态之条目, 被点击之条目
                    )
                } else {
                    this.选中或取消选中一系列列示着的条目(
                        序列动作之意图是选择序列中的所有条目而非取消选中它们, 最末经由交互动作改变其选中之状态之条目, 被点击之条目
                    )
                }

                this.最末经由交互动作改变其选中之状态之条目 = null
                this.最末经由交互动作改变其选中之状态之条目_系选中之 = null
            } else {
                const 被点击的条目即将被选中: boolean = !被点击之条目.已选中

                被点击之条目.已选中 = 被点击的条目即将被选中

                this.最末经由交互动作改变其选中之状态之条目 = 被点击之条目
                this.最末经由交互动作改变其选中之状态之条目_系选中之 = 被点击的条目即将被选中

                this.每当有任何条目之选中状态变动时()
            }
        }
    }





    private mounted (): void {
        const { 本列初始的用以过滤条目之配置 } = this

        if (本列初始的用以过滤条目之配置 instanceof RegExp) {
            this.用以过滤条目之关键词 = 本列初始的用以过滤条目之配置.toString()
        } else if (typeof 本列初始的用以过滤条目之配置 === 'string') {
            this.用以过滤条目之关键词 = 本列初始的用以过滤条目之配置
        }
    }
}
</script>









<style lang="stylus">
// 在多个 Vue 部件（ component ）中均加载某 .styl 文件时，
// 即便采用 @require 语句而非 @import 语句，也无法避免该 .styl 文件之内容
// 编译出的 css 内容重复出现在最终的 .css 文件中。即，这些 css 内容会反复出现！
// 即使变通地采用 stylus 全局变量和 if 语句来包裹 @import 或 @require 语句仍无济于事。
// 故，各 Vue 部件均依赖的 .styl 文件（目前仅《 `0-基础.styl` 》）的加载语句，
// 既不应写在本 <style> 代码块内，也不应写在各 Vue 部件专属的 .styl 文件中。
// 否则，非但 css 会有重复内容，且重复加载的 css 内容其相对于其他 css 内容之顺序也不能确保正确。
// 目前推荐的做法是，始终提醒本工具之使用者在 Vue 的 `main.ts` 或 `main.js` 中加载**两**个 `0-基础.styl` 文件。

@import '../stylus/仅尺寸与排版与关键行为/默认/1-单列.styl'
@import '../stylus/仅着色与装饰/默认/1-单列.styl'
</style>
