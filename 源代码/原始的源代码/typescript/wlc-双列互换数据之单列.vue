<template>
    <div class="吴乐川-双列互换数据-单列" :class="本列之特征样式类名之配置">
        <header class="列首">
            <div class="列标题栏">
                <slot name="皿-标题栏">
                    <div class="列标题栏之默认内容">
                        <h5>{{ 本列之标题栏之文字 }}</h5>
                    </div>
                </slot>
            </div>

            <div class="功能块-条目过滤器">
                <input
                    v-model="用以过滤条目之关键词"
                    :placeholder="条目过滤器之文本输入框之空框状态提示措辞"
                    class="条目过滤器-文本输入框"
                    :class="条目过滤器文本输入框元素之样式类名配置"
                    :disabled="所有未禁止交互之条目之列表.length < 1"
                    @keydown.stop
                    @keyup.stop
                    @keypress.stop
                >
            </div>

            <div class="功能块-全选或全部取消选中">
                <label
                    class="包裹着输入项 包裹着输入项-勾选项"
                    :class="与选中所有条目_含隐藏之条目_之交互相关的汇总数据.交互项之特征样式类名_其根元素"
                >
                    <span
                        class="输入项 输入项-勾选项"
                        :class="与选中所有条目_含隐藏之条目_之交互相关的汇总数据.交互项之特征样式类名_其勾选项之根元素"
                    >
                        <span class="勾选项视觉假体"></span>
                        <input
                            type="checkbox"
                            :checked="与选中所有条目_含隐藏之条目_之交互相关的汇总数据.三态勾选项之状态值 === '已勾选'"
                            :disabled="与选中所有条目_含隐藏之条目_之交互相关的汇总数据.应禁止交互"
                            @change="每当选择所有条目或清除所有条目之选中状态_含隐藏之条目_之交互项动作时($event)"
                        >
                    </span>

                    <span class="输入项配文 输入项配文-勾选项">{{ 与选中所有条目_含隐藏之条目_之交互相关的汇总数据.交互项之界面措辞 }}</span>
                </label>

                <label
                    class="包裹着输入项 包裹着输入项-勾选项"
                    :class="与选中所有条目_仅列示之条目_之交互相关的汇总数据.交互项之特征样式类名_其根元素"
                >
                    <span
                        class="输入项 输入项-勾选项"
                        :class="与选中所有条目_仅列示之条目_之交互相关的汇总数据.交互项之特征样式类名_其勾选项之根元素"
                    >
                        <span class="勾选项视觉假体" ></span>
                        <input
                            type="checkbox"
                            :checked="与选中所有条目_仅列示之条目_之交互相关的汇总数据.三态勾选框之状态值 === '已勾选'"
                            :disabled="与选中所有条目_仅列示之条目_之交互相关的汇总数据.应禁止交互"
                            @change="每当选择所有条目或清除所有条目之选中状态_仅列示之条目_之交互项动作时($event)"
                        >
                    </span>

                    <span class="输入项配文 输入项配文-勾选项">{{ 与选中所有条目_仅列示之条目_之交互相关的汇总数据.交互项之界面措辞 }}</span>
                </label>
            </div>

            <dl class="字典式列表 功能块-条目统计">
                <div class="字典式列表之条目 字典式列表之条目--所有条目之统计">
                    <dt><span>总数</span></dt>

                    <dd>
                        <span class="值 值--总数">{{ 所有条目之总数 }}</span>

                        <span class="括弧 括弧--左">（</span>
                        <span class="值-前缀 值-前缀--列示数">已列示</span>
                        <span class="值 值--列示数">{{ 当下列示着的所有条目之列表.length }}</span>
                        <span class="括弧 括弧--右">）</span>
                    </dd>
                </div>

                <div class="字典式列表之条目 字典式列表之条目--已选中条目之统计">
                    <dt><span>已选中</span></dt>

                    <dd>
                        <span class="值 值--总数">{{ 当下已选中的所有条目_含隐藏之条目_之列表.length }}</span>

                        <span class="括弧 括弧--左">（</span>
                        <span class="值-前缀 值-前缀--列示数">已列示</span>
                        <span class="值 值--列示数">{{ 当下已选中的所有条目_仅列示的条目_之列表.length }}</span>
                        <span class="括弧 括弧--右">）</span>
                    </dd>
                </div>
            </dl>
        </header>

        <div class="功能块-条目列表皿">
            <article
                v-if="当下期望列示的条目过多故暂不列示任何条目"
                class="消息文本皿 标准配色-幽暗 条目列表之提示语"
            >
                <p>{{ 用以过滤条目之关键词 ? '符合筛选条件的' : '候选' }}条目太多，<span class="尽量不换行之短语">达<strong class="值 值-期望列示之条目总数">{{
                    匹配当下过滤配置之所有条目之列表.length
                }}</strong>条，</span>已逾<span class="尽量不换行之短语"><strong class="值 值-条目总数之限制数">{{
                    允许列示的条目数之上限_最终采纳值
                }}</strong>条</span>之限。为确保程序不致僵死，暂不列示任何条目。</p>
                <p><em>请先输入筛选关键词，以减少须列示的条目。</em></p>
            </article>

            <ol v-else class="条目列表">
                <li
                    v-for="条目 in 当下列示着的所有条目之列表"
                    :key="条目.唯一标识"
                    class="条目"
                ><span
                    class="条目视觉主体"
                    :class="求某条目之样式类名集_其根元素(条目)"
                    @click="每当点击某条目后(条目, $event)"
                ><span class="选项配文 选项配文-勾选项">{{ 条目.在界面中的称谓 }}</span></span></li>
            </ol>
        </div>
    </div>
</template>

<script lang="ts">
import { Vue, Component, Prop, Model, Watch } from 'vue-property-decorator'

import {
    求可靠的文本,
    尽可能将用户输入的文本视为正则表达式并用以过滤列表,
} from './工具集'

type 范_界面元素之样式类名之配置 = Wlc双列互换数据.范_界面元素之样式类名之配置;
type 范_三态勾选框之状态值 = Wlc双列互换数据.范_三态勾选框之状态值;
type 范_条目 = Wlc双列互换数据.范_条目;
type 范_条目之列表 = Wlc双列互换数据.范_条目之列表;
type 范_条目之唯一标识之列表 = Wlc双列互换数据.范_条目之唯一标识之列表;
type 范_各列新增条目之插入规则 = Wlc双列互换数据.范_各列新增条目之插入规则;
type 范_各列条目排序之函数 = Wlc双列互换数据.范_各列条目排序之函数;

const 构建实用的条目总表_发起之原因_所有条目之列表已变动 = '【所有条目之列表】变动'
const 构建实用的条目总表_发起之原因_当下选中的所有条目之唯一标识之列表已变动 = '【当下选中的所有条目之唯一标识之列表】变动'

type 范_构建实用的条目总表_发起之原因 = (
    | '【所有条目之列表】变动'
    | '【当下选中的所有条目之唯一标识之列表】变动'
);

const 单列允许列示的条目数之上限_默认值 = 500

export const 各列条目排序之函数所有允许的值值列表: 范_各列新增条目之插入规则[] = [
    '总是追加在尾部',
    '总是追加在首部',
    '总是参与排序',
]

@Component({})
export default class Wlc双列互换数据之单列 extends Vue {
    @Model('选中的条目已变动') public readonly 当下选中的所有条目之唯一标识之列表?: 范_条目之唯一标识之列表

    @Prop() public readonly 本列之称谓?: string
    @Prop() public readonly 本列之特征样式类名之配置?: 范_界面元素之样式类名之配置
    @Prop() public readonly 允许列示的条目数之上限?: number | string
    @Prop() public readonly 所有条目之列表?: 范_条目之列表
    @Prop() public readonly 新增条目之插入规则?: 范_各列新增条目之插入规则
    @Prop() public readonly 条目排序之函数?: 范_各列条目排序之函数
    @Prop() public readonly 本列初始的用以过滤条目之配置?: string | RegExp
    @Prop() public readonly 对列当下正以视觉强调引导用户操作之?: boolean
    @Prop() public readonly 在对列以视觉强调引导用户操作之时_本列之强调不应有动画?: boolean





    private 用以过滤条目之关键词: string = ''
    private 所有条目之列表_最终采纳值: 范_条目之列表 = []
    private 所有条目之列表_最终采纳值_求解之期待: null | Promise<boolean> = null
    private 所有条目之列表_最终采纳值_求解之期待之原因: string = ''
    private 三态勾选框_所有条目_含隐藏之条目_之勾选状态统计_之状态值: 范_三态勾选框之状态值 = '未勾选'
    private 三态勾选框_所有条目_仅列示之条目_之勾选状态统计_之状态值: 范_三态勾选框之状态值 = '未勾选'
    private 最末经由交互动作改变其选中之状态之条目: 范_条目 | null = null
    private 最末经由交互动作改变其选中之状态之条目_系选中之: boolean | null = null




    private get 本列之称谓_最终采纳值 (): string {
        return 求可靠的文本(this.本列之称谓, '无名列', false)
    }

    private get 日志前缀 (): string {
        return `Vue 部件 <Wlc双列互换数据之单列> “ ${this.本列之称谓_最终采纳值} ” ：`
    }

    private get 本列之标题栏之文字 (): string {
        return this.本列之称谓_最终采纳值
    }

    private get 允许列示的条目数之上限_最终采纳值 (): number {
        const 外界给出值 = this.允许列示的条目数之上限

        let 拟采纳值: number = NaN
        if (typeof 外界给出值 === 'number') {
            拟采纳值 = 外界给出值
        } else if (typeof 外界给出值 === 'string' && 外界给出值.trim()) {
            拟采纳值 = +外界给出值.trim()
        }

        return 拟采纳值 > 0 ? 拟采纳值 : 单列允许列示的条目数之上限_默认值
    }

    private get 新增条目之插入规则_最终采纳值 (): 范_各列新增条目之插入规则 {
        const 外界给出值 = this.新增条目之插入规则
        const 排序函数确已给出: boolean = typeof this.条目排序之函数 === 'function'

        let 决定采纳的值: 范_各列新增条目之插入规则
        if (typeof 外界给出值 === 'string' && 各列条目排序之函数所有允许的值值列表.includes(外界给出值)) {
            决定采纳的值 = 外界给出值
        } else {
            决定采纳的值 = 排序函数确已给出 ? '总是参与排序' : '总是追加在尾部'
        }

        return 决定采纳的值
    }

    private get 所有条目之总数 (): number {
        return this.所有条目之列表_最终采纳值.length
    }

    private get 条目过滤器之文本输入框之空框状态提示措辞 (): string {
        return this.所有未禁止交互之条目之列表.length > 0 ? '筛选条目（可用正则表达式）' : '无条目可筛选'
        // return this.所有未禁止交互之条目之列表.length > 0 ? `筛选【${this.本列之称谓_最终采纳值}】（可用正则表达式）` : '无条目可筛选'
    }

    private get 所有未禁止交互之条目之列表 (): 范_条目之列表 {
        return this.所有条目之列表_最终采纳值.filter(条目 => !条目.已禁止选择)
    }

    private get 匹配当下过滤配置之所有条目之列表 (): 范_条目之列表 {
        return 尽可能将用户输入的文本视为正则表达式并用以过滤列表<范_条目>(
            this.所有条目之列表_最终采纳值,
            this.用以过滤条目之关键词,
            条目 => 条目.在界面中的称谓
        )
    }

    private get 当下列示着的所有条目之列表 (): 范_条目之列表 {
        const 期望列示的所有条目 = this.匹配当下过滤配置之所有条目之列表
        const { 允许列示的条目数之上限_最终采纳值 } = this

        const 匹配的条目过多故暂不应列示任何条目 = 期望列示的所有条目.length > 允许列示的条目数之上限_最终采纳值
        if (匹配的条目过多故暂不应列示任何条目) {
            return []
        } else {
            return 期望列示的所有条目
        }
    }

    private get 当下列示着的所有未禁止交互之条目之列表 (): 范_条目之列表 {
        return this.当下列示着的所有条目之列表.filter(条目 => !条目.已禁止选择)
    }

    private get 当下期望列示的条目过多故暂不列示任何条目 (): boolean {
        return this.匹配当下过滤配置之所有条目之列表.length > 0 && this.当下列示着的所有条目之列表.length === 0
    }

    private get 当下已选中的所有条目_含隐藏之条目_之列表 (): 范_条目之列表 {
        return this.所有未禁止交互之条目之列表.filter(条目 => !!条目.已选中)
    }

    private get 当下已选中的所有条目_仅列示的条目_之列表 (): 范_条目之列表 {
        return this.当下列示着的所有未禁止交互之条目之列表.filter(条目 => !!条目.已选中)
    }

    private get 条目过滤器文本输入框元素之样式类名配置 (): 范_界面元素之样式类名之配置 {
        const {
            对列当下正以视觉强调引导用户操作之,
            在对列以视觉强调引导用户操作之时_本列之强调不应有动画,
            当下期望列示的条目过多故暂不列示任何条目,
        } = this

        const 应给予视觉强调以引导用户来此: boolean = 当下期望列示的条目过多故暂不列示任何条目

        const 给予的视觉强调不应为动画: boolean = !!(
            应给予视觉强调以引导用户来此 &&
            对列当下正以视觉强调引导用户操作之 &&
            在对列以视觉强调引导用户操作之时_本列之强调不应有动画
        )

        return {
            '应给予视觉强调以引导用户来此': 当下期望列示的条目过多故暂不列示任何条目,
            '给予的视觉强调不应为动画': 给予的视觉强调不应为动画,
        }
    }

    private get 当下有否视觉强调动画之结论 (): boolean {
        const 结论: boolean = !!(
            this.当下期望列示的条目过多故暂不列示任何条目
        )

        return 结论
    }

    private get 与选中所有条目_含隐藏之条目_之交互相关的汇总数据 () {
        return this.求与选中所有条目之交互相关的汇总数据(true)
    }

    private get 与选中所有条目_仅列示之条目_之交互相关的汇总数据 () {
        return this.求与选中所有条目之交互相关的汇总数据(false)
    }





    @Watch('所有条目之列表', { immediate: true })
    private 在外界给出的所有条目之列表变动后 () {
        this.根据外界给出的条件构建实用的条目总表(构建实用的条目总表_发起之原因_所有条目之列表已变动)
    }

    @Watch('当下选中的所有条目之唯一标识之列表', { immediate: true })
    private 在外界给出的当下选中的所有条目之唯一标识之列表变动后 () {
        this.根据外界给出的条件构建实用的条目总表(构建实用的条目总表_发起之原因_当下选中的所有条目之唯一标识之列表已变动)
    }

    @Watch('当下有否视觉强调动画之结论', { immediate: true })
    private 在外界给出的当下有否视觉强调动画之结论变动后 (结论: boolean) {
        this.发布事件_视觉强调之状态已变动(结论)
    }





    private 根据外界给出的条件构建实用的条目总表 (本次原因: 范_构建实用的条目总表_发起之原因): Promise<boolean> {
        const { 日志前缀 } = this

        const _构建实用的条目总表 = () => {
            let 给出的所有条目之原始无序列表: 范_条目之列表
            let 当下选中的所有条目之唯一标识之列表: 范_条目之唯一标识之列表

            if (Array.isArray(this.所有条目之列表)) {
                给出的所有条目之原始无序列表 = this.所有条目之列表
            } else {
                给出的所有条目之原始无序列表 = []
            }

            if (Array.isArray(this.当下选中的所有条目之唯一标识之列表)) {
                当下选中的所有条目之唯一标识之列表 = this.当下选中的所有条目之唯一标识之列表
            } else {
                当下选中的所有条目之唯一标识之列表 = []
            }

            const 当下选中的所有条目之唯一标识在新的所有条目列表中的存在性统计: { [某条目之唯一标识: string]: boolean } = {}

            Object.keys(当下选中的所有条目之唯一标识之列表).map(某条目之唯一标识 => {
                当下选中的所有条目之唯一标识在新的所有条目列表中的存在性统计[某条目之唯一标识] = false
            })

            const 旧有的所有条目之列表: 范_条目之列表 = this.所有条目之列表_最终采纳值

            const 旧有的所有条目之唯一标识之列表: 范_条目之唯一标识之列表 = 旧有的所有条目之列表.map(条目 => 条目.唯一标识)
            const 给出的所有条目之唯一标识之列表: 范_条目之唯一标识之列表 = 给出的所有条目之原始无序列表.map(条目 => 条目.唯一标识)

            const 在日志中列举条目之数量之上限 = 12; console.debug(`${日志前缀}\n\t正在构建新的【条目总表之最终采纳值】。`,
                '\n\t原因：', 本次原因, '。',
                '\n\t此时：',
                '\n\t\t给出的所有条目之原始无序列表：', 给出的所有条目之原始无序列表.length, '条。',
                给出的所有条目之原始无序列表.length === 0 ? '' : `\n\t\t\t有：${给出的所有条目之唯一标识之列表.slice(0, 在日志中列举条目之数量之上限).join('、')}${给出的所有条目之原始无序列表.length > 在日志中列举条目之数量之上限 ? '……' : '。'}`,
                '\n\t\t选中的所有条目之列表：', 当下选中的所有条目之唯一标识之列表.length, '条。',
                当下选中的所有条目之唯一标识之列表.length === 0 ? '' : `\n\t\t\t有：${当下选中的所有条目之唯一标识之列表.slice(0, 在日志中列举条目之数量之上限).join('、')}${当下选中的所有条目之唯一标识之列表.length > 在日志中列举条目之数量之上限 ? '……' : '。'}`
            )

            let 选中的条目之列表将会变化: boolean = false

            const 应保留的旧有条目之列表: 范_条目之列表 = 旧有的所有条目之列表.filter(条目 => {
                if (!条目) { return false }

                const {
                    唯一标识: 该条目之唯一标识,
                    已选中: 该条目原本已选中,
                    已禁止选择: 该条目已禁止选择,
                } = 条目

                const 该条目应保留: boolean = 给出的所有条目之唯一标识之列表.includes(该条目之唯一标识)

                if (该条目应保留) {
                    const 该条目此后应选中 = !该条目已禁止选择 && 当下选中的所有条目之唯一标识之列表.includes(该条目之唯一标识)
                    if (该条目原本已选中 !== 该条目此后应选中) {
                        条目.已选中 = 该条目此后应选中
                        选中的条目之列表将会变化 = true
                    }
                    if (该条目此后应选中) {
                        当下选中的所有条目之唯一标识在新的所有条目列表中的存在性统计[该条目之唯一标识] = true
                    }
                } else {
                    if (该条目原本已选中) {
                        选中的条目之列表将会变化 = true
                    }
                }

                return 该条目应保留
            })

            if (Object.keys(当下选中的所有条目之唯一标识在新的所有条目列表中的存在性统计).some(某条目之唯一标识 => !当下选中的所有条目之唯一标识在新的所有条目列表中的存在性统计[某条目之唯一标识])) {
                选中的条目之列表将会变化 = true
            }

            const 应追加至新列表的条目之列表: 范_条目之列表 = 给出的所有条目之原始无序列表.filter(条目 => {
                if (!条目) { return false }

                const {
                    唯一标识: 该条目之唯一标识,
                } = 条目

                const 该条目应添加到新列表中去: boolean = !旧有的所有条目之唯一标识之列表.includes(该条目之唯一标识)

                if (该条目应添加到新列表中去) {
                    条目.已选中 = false
                    if (!条目.已禁止选择) { 条目.已禁止选择 = false } // 防止外界省略该值，在此初始化之。
                }

                return 该条目应添加到新列表中去
            })

            const {
                新增条目之插入规则_最终采纳值,
                条目排序之函数,
            } = this

            const 给出了排序函数 = typeof 条目排序之函数 === 'function'
            const 应重新排序 = 给出了排序函数 && (新增条目之插入规则_最终采纳值 === '总是参与排序' || 旧有的所有条目之列表.length === 0)

            let 所有条目之列表_最终采纳的新值: 范_条目之列表

            if (新增条目之插入规则_最终采纳值 === '总是追加在首部') {
                所有条目之列表_最终采纳的新值 = [
                    ...应追加至新列表的条目之列表,
                    ...应保留的旧有条目之列表,
                ]
            } else {
                所有条目之列表_最终采纳的新值 = [
                    ...应保留的旧有条目之列表,
                    ...应追加至新列表的条目之列表,
                ]
            }

            if (应重新排序) {
                所有条目之列表_最终采纳的新值.sort(条目排序之函数)
            }

            所有条目之列表_最终采纳的新值.forEach(条目 => {
                条目.唯一标识
            })

            this.所有条目之列表_最终采纳值 = 所有条目之列表_最终采纳的新值

            if (选中的条目之列表将会变化) {
                this.每当有任何条目之选中状态变动时()
            }

            return 选中的条目之列表将会变化
        }

        if (!this.所有条目之列表_最终采纳值_求解之期待) {
            const 所有条目之列表_最终采纳值_求解之期待 = new Promise<boolean>((令期待落实, 令期待落空) => {
                const 选中的条目之列表将会变化 = _构建实用的条目总表()
                this.$nextTick(() => {
                    令期待落实(选中的条目之列表将会变化)
                    this.所有条目之列表_最终采纳值_求解之期待 = null
                    this.所有条目之列表_最终采纳值_求解之期待之原因 = ''
                })
            })

            this.所有条目之列表_最终采纳值_求解之期待之原因 = 本次原因
            this.所有条目之列表_最终采纳值_求解之期待 = 所有条目之列表_最终采纳值_求解之期待
        } else {
            console.debug(`${日志前缀}\n\t根据外界给出的条件构建实用的条目总表() 不执行。\n\t因仍在进行因`,
                this.所有条目之列表_最终采纳值_求解之期待之原因, '而起的任务。',
                '\n\t附本次原因：', 本次原因, '。'
            )
        }

        return this.所有条目之列表_最终采纳值_求解之期待
    }

    private 求某条目之样式类名集_其根元素 (条目: 范_条目) {
        if (!条目) { return null }
        const 已选中 = !!条目.已选中
        const 已禁止选择 = !!条目.已禁止选择
        return {
            '已选中': 已选中,
            '已禁止选择': 已禁止选择,
        }
    }

    private 求与选中所有条目之交互相关的汇总数据 (本次统计时应将暂不可见的条目一并计入?: boolean) {
        type 范_交互项之界面措辞 = (
            | '--'
            | '无可勾选项'
            | '选中所有条目（含未列示条目）'
            | '选中所有条目（仅列示条目）'
            | '清除所有选择（含未列示条目）'
            | '清除所有选择（仅列示条目）'
        );

        type 范_交互项之特征样式类名_其根元素 = Wlc双列互换数据.范_界面元素之样式类名之配置<(
            | '已禁止交互'
            | '已勾选'
            | '未勾选'
            | '部分勾选'
        )>;

        type 范_交互项之特征样式类名_其勾选项之根元素 = 范_交互项之特征样式类名_其根元素;

        let 交互项之特征样式类名_其根元素: 范_交互项之特征样式类名_其根元素 = null
        let 交互项之特征样式类名_其勾选项之根元素: 范_交互项之特征样式类名_其勾选项之根元素 = null

        let 交互项之界面措辞: 范_交互项之界面措辞

        const 所有参与统计之条目: 范_条目之列表 = 本次统计时应将暂不可见的条目一并计入
            ? this.所有未禁止交互之条目之列表
            : this.当下列示着的所有未禁止交互之条目之列表

        const 三态勾选框之状态值: 范_三态勾选框之状态值 = 本次统计时应将暂不可见的条目一并计入
            ? this.三态勾选框_所有条目_含隐藏之条目_之勾选状态统计_之状态值
            : this.三态勾选框_所有条目_仅列示之条目_之勾选状态统计_之状态值

        const 界面措辞之统一后缀 = 本次统计时应将暂不可见的条目一并计入 ? '（含未列示条目）' : '（仅列示条目）'

        const { 所有条目之总数, 当下列示着的所有条目之列表 } = this
        const 所有条目均已列示: boolean = 当下列示着的所有条目之列表.length === 所有条目之总数

        const 本次参与统计的条目数为零: boolean = 所有参与统计之条目.length === 0
        const 本次统计之条目之含义并非所有条目但数目恰与总条目数相同_哪怕总条目数为零: boolean = (!本次统计时应将暂不可见的条目一并计入 && 所有条目均已列示)
        const 应禁止交互: boolean = 本次参与统计的条目数为零 || 本次统计之条目之含义并非所有条目但数目恰与总条目数相同_哪怕总条目数为零
        if (应禁止交互) {
            交互项之特征样式类名_其根元素 = '已禁止交互'
            交互项之特征样式类名_其勾选项之根元素 = '已禁止交互'

            if (本次统计之条目之含义并非所有条目但数目恰与总条目数相同_哪怕总条目数为零) {
                交互项之界面措辞 = '--'
            } else {
                交互项之界面措辞 = '无可勾选项'
            }
        } else {
            if (三态勾选框之状态值 === '未勾选') {

                交互项之界面措辞 = `选中所有条目${界面措辞之统一后缀}`
                交互项之特征样式类名_其根元素 = '未勾选'
                交互项之特征样式类名_其勾选项之根元素 = '未勾选'

            } else if (三态勾选框之状态值 === '已勾选') {

                交互项之界面措辞 = `清除所有选择${界面措辞之统一后缀}`
                交互项之特征样式类名_其根元素 = '已勾选'
                交互项之特征样式类名_其勾选项之根元素 = '已勾选'

            } else {

                交互项之界面措辞 = `选中所有条目${界面措辞之统一后缀}`
                交互项之特征样式类名_其根元素 = '部分勾选'
                交互项之特征样式类名_其勾选项之根元素 = '部分勾选'

            }
        }

        const 汇总数据 = {
            交互项之界面措辞,
            应禁止交互,
            三态勾选框之状态值,
            交互项之特征样式类名_其根元素,
            交互项之特征样式类名_其勾选项之根元素,
        }

        // console.debug(`${this.日志前缀}\n\t含隐藏条目：`, 本次统计时应将暂不可见的条目一并计入, '\t\t状态：', 汇总数据.三态勾选框之状态值)

        return 汇总数据
    }

    private 选中或取消选中一系列列示着的条目 (本次目的是选中这一系列条目?: boolean, 条目甲?: any, 条目乙?: any): void {
        this.选中后取消选中一系列条目(this.当下列示着的所有条目之列表, 本次目的是选中这一系列条目, 条目甲, 条目乙)
    }

    private 选中或取消选中一系列条目_含隐藏之条目 (本次目的是选中这一系列条目?: boolean, 条目甲?: any, 条目乙?: any): void {
        this.选中后取消选中一系列条目(this.所有条目之列表_最终采纳值, 本次目的是选中这一系列条目, 条目甲, 条目乙)
    }

    private 选中后取消选中一系列条目 (应考察的所有条目之列表?: 范_条目之列表, 本次目的是选中这一系列条目?: boolean, 条目甲?: any, 条目乙?: any): void {
        if (!Array.isArray(应考察的所有条目之列表)) { return }
        if (!条目甲 || !条目乙) { return }

        const 条目甲之列表编号: number = 应考察的所有条目之列表.indexOf(条目甲)
        const 条目乙之列表编号: number = 应考察的所有条目之列表.indexOf(条目乙)

        if (条目甲之列表编号 < 0 || 条目乙之列表编号 < 0 || 条目甲之列表编号 === 条目乙之列表编号) {
            return
        }

        const 起始条目之列表编号: number = Math.min(条目甲之列表编号, 条目乙之列表编号)
        const 结束条目之列表编号: number = Math.max(条目甲之列表编号, 条目乙之列表编号)

        let 条目选中之情况有变动: boolean = false
        应考察的所有条目之列表.forEach((条目, 该条目之列表编号) => {
            if (条目.已禁止选择) { return }

            const 条目原本已选中: boolean = !!条目.已选中
            const 条目参与本集体动作: boolean = 起始条目之列表编号 <= 该条目之列表编号 && 该条目之列表编号 <= 结束条目之列表编号
            if (条目参与本集体动作) {
                if (本次目的是选中这一系列条目) {
                    条目.已选中 = true
                    if (!条目原本已选中) { 条目选中之情况有变动 = true }
                } else {
                    条目.已选中 = false
                    if (条目原本已选中) { 条目选中之情况有变动 = true }
                }
            }
        })

        if (条目选中之情况有变动) {
            this.每当有任何条目之选中状态变动时()
        }
    }

    /**
     * 最终决定不厌其烦的在 4 处各自调用该动作。
     *
     * 这是因为如果改用 `@Watch('当下已选中的所有条目_含隐藏之条目_之列表')` 一值：
     * -   则某些时候当 `当下已选中的所有条目_含隐藏之条目_之列表` 变动时，其 `@Watch` 的处理程序会重复调用 2 次下列动作。而正确的行为应是仅调用一次。
     * -   另，在尝试 `@Watch` 之做法时，暂未遇到重复调用该动作“多于 2 次”之情形。
     */
    private 每当有任何条目之选中状态变动时 (): void {
        this.统计所有条目_含隐藏条目_之勾选状态()
        this.统计所有条目_仅列示条目_之勾选状态()
        this.发布事件_选中的条目已变动()
    }

    private _统计某应考察之条目之列表中的勾选状态 (所有应考察之条目: 范_条目之列表): 范_三态勾选框之状态值 {
        const 考察的条目中已选中条目之总数: number = 所有应考察之条目.filter(条目 => 条目.已选中).length
        const 所有应考察之条目之总数: number = 所有应考察之条目.length

        let 三态勾选框之状态值: 范_三态勾选框之状态值 = '未勾选'

        if (所有应考察之条目之总数 > 0) {
            if (考察的条目中已选中条目之总数 === 所有应考察之条目之总数) {
                三态勾选框之状态值 = '已勾选'
            } else if (考察的条目中已选中条目之总数 > 0) {
                三态勾选框之状态值 = '部分勾选'
            }
        }

        return 三态勾选框之状态值
    }

    private 统计所有条目_含隐藏条目_之勾选状态 (): void {
        this.三态勾选框_所有条目_含隐藏之条目_之勾选状态统计_之状态值 = this._统计某应考察之条目之列表中的勾选状态(this.所有未禁止交互之条目之列表)
    }

    private 统计所有条目_仅列示条目_之勾选状态 (): void {
        this.三态勾选框_所有条目_仅列示之条目_之勾选状态统计_之状态值 = this._统计某应考察之条目之列表中的勾选状态(this.当下列示着的所有未禁止交互之条目之列表)
    }





    private 发布事件_选中的条目已变动 () {
        const 事件之记载: 范_条目之唯一标识之列表 = this.所有条目之列表_最终采纳值
            .filter(条目 => !!条目.已选中)
            .map(条目 => 条目.唯一标识)

        this.$emit('选中的条目已变动', 事件之记载)
    }

    private 发布事件_视觉强调之状态已变动 (当下有否视觉强调动画之结论?: boolean) {
        const 事件之记载: boolean = !!当下有否视觉强调动画之结论
        this.$emit('视觉强调之状态已变动', 事件之记载)
    }





    private 每当选择所有条目或清除所有条目之选中状态_含隐藏之条目_之交互项动作时 (界面表单元素变动事件之记载: InputEvent) {
        if (!界面表单元素变动事件之记载.target) { return }
        const 界面表单元素 = 界面表单元素变动事件之记载.target as HTMLInputElement
        this.所有未禁止交互之条目之列表.forEach(条目 => { 条目.已选中 = 界面表单元素.checked })
        this.每当有任何条目之选中状态变动时()
    }

    private 每当选择所有条目或清除所有条目之选中状态_仅列示之条目_之交互项动作时 (界面表单元素变动事件之记载: InputEvent) {
        if (!界面表单元素变动事件之记载.target) { return }
        const 界面表单元素 = 界面表单元素变动事件之记载.target as HTMLInputElement
        this.当下列示着的所有未禁止交互之条目之列表.forEach(条目 => { 条目.已选中 = 界面表单元素.checked })
        this.每当有任何条目之选中状态变动时()
    }

    private 每当点击某条目后 (被点击之条目: 范_条目, 事件之记载: PointerEvent) {
        if (被点击之条目 && 事件之记载) {
            const {
                最末经由交互动作改变其选中之状态之条目,
                最末经由交互动作改变其选中之状态之条目_系选中之,
            } = this

            const {
                shiftKey: 点击该条目时按住了_shift_键,
                ctrlKey: 点击该条目时也按住了_ctrl_键,
            } = 事件之记载

            if (!!最末经由交互动作改变其选中之状态之条目 && 点击该条目时按住了_shift_键) {
                const 序列动作之意图是选择序列中的所有条目而非取消选中它们: boolean = (最末经由交互动作改变其选中之状态之条目_系选中之 as boolean)

                if (点击该条目时也按住了_ctrl_键) {
                    this.选中或取消选中一系列条目_含隐藏之条目(
                        序列动作之意图是选择序列中的所有条目而非取消选中它们, 最末经由交互动作改变其选中之状态之条目, 被点击之条目
                    )
                } else {
                    this.选中或取消选中一系列列示着的条目(
                        序列动作之意图是选择序列中的所有条目而非取消选中它们, 最末经由交互动作改变其选中之状态之条目, 被点击之条目
                    )
                }

                this.最末经由交互动作改变其选中之状态之条目 = null
                this.最末经由交互动作改变其选中之状态之条目_系选中之 = null
            } else {
                const 被点击的条目即将被选中: boolean = !被点击之条目.已选中

                被点击之条目.已选中 = 被点击的条目即将被选中

                this.最末经由交互动作改变其选中之状态之条目 = 被点击之条目
                this.最末经由交互动作改变其选中之状态之条目_系选中之 = 被点击的条目即将被选中

                this.每当有任何条目之选中状态变动时()
            }
        }
    }





    private created (): void {
        const { 本列初始的用以过滤条目之配置 } = this

        if (本列初始的用以过滤条目之配置 instanceof RegExp) {
            this.用以过滤条目之关键词 = 本列初始的用以过滤条目之配置.toString()
        } else if (typeof 本列初始的用以过滤条目之配置 === 'string') {
            this.用以过滤条目之关键词 = 本列初始的用以过滤条目之配置
        }
    }
}
</script>
