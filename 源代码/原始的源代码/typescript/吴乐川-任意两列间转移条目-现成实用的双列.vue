<template>
    <div class="吴乐川-任意两列间转移条目-现成实用的双列">
        <header class="总标题栏">
            <slot name="界面皿-总标题栏" v-bind="用于各界面皿之状态集"></slot>
        </header>

        <div class="容纳着双列的中央主体">
            <Wlc任意两列间转移条目_单列
                v-model="甲列之数据集.当下选中的所有条目之唯一标识之列表"
                class="标准双列模式下的甲列"
                :应全面禁止交互="应全面禁止交互"
                :本列之特征样式类名之配置="甲列之特征样式类名之配置"
                :本列之称谓="甲列之称谓_最终采纳值"
                :允许列示的条目数之上限="单列允许列示的条目数之上限"
                :所有条目之列表="甲列之数据集.所有条目之列表"
                :新增条目之插入规则="各列新增条目之插入规则"
                :条目排序之函数="各列条目排序之函数"
                :本列初始的用以过滤条目之配置="甲列初始的用以过滤条目之配置"
                :当下另有他列优先于本列采取视觉强调引导用户操作之="false"
                :不应创建底部栏目="各列均不应创建底部栏目"
                :vue部件之定义_订制的主表条目="vue部件之定义_订制的主表条目"
                :应在控制台输出详尽的调试信息="应在控制台输出详尽的调试信息"
                @内部某元素之视觉强调之状态已变动="甲列之数据集.当下正在通过视觉强调动画引导用户 = $event"
            ></Wlc任意两列间转移条目_单列>

            <slot name="界面皿-中央列" v-bind="用于各界面皿之状态集">
                <Wlc任意两列间转移条目_两列之间之竖栏_默认形态
                    :应全面禁止交互="应全面禁止交互"
                    :按钮上的措辞_将条目从甲列迁移至乙列="按钮上的措辞_中央竖栏默认内容_将条目从甲列迁移至乙列"
                    :按钮上的措辞_将条目从乙列迁移至甲列="按钮上的措辞_中央竖栏默认内容_将条目从乙列迁移至甲列"
                    :甲列当下选中的条目之总数="用于各界面皿之状态集.甲列当下选中的条目之总数"
                    :乙列当下选中的条目之总数="用于各界面皿之状态集.乙列当下选中的条目之总数"
                    @请求将甲列选中之条目迁移至乙列="将甲列选中的条目迁移至乙列()"
                    @请求将乙列选中之条目迁移至甲列="将乙列选中的条目迁移至甲列()"
                ></Wlc任意两列间转移条目_两列之间之竖栏_默认形态>
            </slot>

            <Wlc任意两列间转移条目_单列
                v-model="乙列之数据集.当下选中的所有条目之唯一标识之列表"
                class="标准双列模式下的乙列"
                :应全面禁止交互="应全面禁止交互"
                :本列之特征样式类名之配置="乙列之特征样式类名之配置"
                :本列之称谓="乙列之称谓_最终采纳值"
                :允许列示的条目数之上限="单列允许列示的条目数之上限"
                :所有条目之列表="乙列之数据集.所有条目之列表"
                :新增条目之插入规则="各列新增条目之插入规则"
                :条目排序之函数="各列条目排序之函数"
                :本列初始的用以过滤条目之配置="乙列初始的用以过滤条目之配置"
                :当下另有他列优先于本列采取视觉强调引导用户操作之="甲列之数据集.当下正在通过视觉强调动画引导用户"
                :不应创建底部栏目="各列均不应创建底部栏目"
                :vue部件之定义_订制的主表条目="vue部件之定义_订制的主表条目"
                :应在控制台输出详尽的调试信息="应在控制台输出详尽的调试信息"
                @内部某元素之视觉强调之状态已变动="乙列之数据集.当下正在通过视觉强调动画引导用户 = $event"
            ></Wlc任意两列间转移条目_单列>
        </div>

        <footer class="底部内容栏">
            <slot name="界面皿-底部内容栏" v-bind="用于各界面皿之状态集">
                <div class="底部内容栏之默认内容">
                    <div class="功能块 功能块--针对甲列">
                        <div class="功能单体 功能单体-主体为按钮">
                            <button
                                class="迁移条目之按钮 迁移条目之按钮--甲列至乙列"
                                :disabled="应全面禁止交互 || 用于各界面皿之状态集.甲列当下没有条目拟迁移至乙列"
                                @click="每当点击用以将甲列选中之条目迁移至乙列之按钮后()"
                            >{{ 按钮上的措辞_底部内容栏默认内容_将条目从甲列迁移至乙列_最终采纳值 }}</button>
                            <sup
                                v-if="!用于各界面皿之状态集.甲列当下没有条目拟迁移至乙列"
                                class="角标 角标-位置应居左"
                            >{{ 用于各界面皿之状态集.甲列当下选中的条目之总数 }}</sup>
                        </div>
                    </div>

                    <div class="用以影响柔性布局之中央占位块"></div>

                    <div class="功能块 功能块--针对乙列">
                        <div class="功能单体 功能单体-主体为按钮">
                            <button
                                class="迁移条目之按钮 迁移条目之按钮--乙列至甲列"
                                :disabled="应全面禁止交互 || 用于各界面皿之状态集.乙列当下没有条目拟迁移至甲列"
                                @click="每当点击用以将乙列选中之条目迁移至甲列之按钮后()"
                            >{{ 按钮上的措辞_底部内容栏默认内容_将条目从乙列迁移至甲列_最终采纳值 }}</button>
                            <sup
                                v-if="!用于各界面皿之状态集.乙列当下没有条目拟迁移至甲列"
                                class="角标"
                            >{{ 用于各界面皿之状态集.乙列当下选中的条目之总数 }}</sup>
                        </div>
                    </div>
                </div>
            </slot>
        </footer>
    </div>
</template>









<script lang="ts">
import { Vue, Component, Prop, Model, Watch } from 'vue-property-decorator'

import Wlc任意两列间转移条目_单列 from './吴乐川-任意两列间转移条目-单列.vue'
import Wlc任意两列间转移条目_两列之间之竖栏_默认形态 from './吴乐川-任意两列间转移条目-两列之间之默认竖栏.vue'

import {
    求可靠的文本,
} from './辅助工具集'

import {
    将某列选中的条目迁移至另一列,
} from './吴乐川-任意两列间转移条目-_专用工具集'





type 范_界面元素之样式类名之配置 = Wlc任意两列间转移条目.泛范_界面元素之样式类名之配置<string>;

type 范_条目之唯一标识之列表 = Wlc任意两列间转移条目.范_条目之唯一标识之列表;
type 范_基础条目之列表 = Wlc任意两列间转移条目.范_基础条目之列表;
type 范_内用格式之条目 = Wlc任意两列间转移条目.范_内用格式之条目;
type 范_内用格式之条目之列表 = Wlc任意两列间转移条目.范_内用格式之条目之列表;

type 范_状态汇总数据 = Wlc任意两列间转移条目.范_状态汇总数据;
type 范_各列新增条目之插入规则 = Wlc任意两列间转移条目.范_各列新增条目之插入规则;
type 范_各列条目排序之函数 = Wlc任意两列间转移条目.范_各列条目排序之函数;

type 范_Vue动态部件之Is属性可接受的数据_但不可为部件名称字符串 = Wlc任意两列间转移条目.范_Vue动态部件之Is属性可接受的数据_但不可为部件名称字符串;

type 范_单列之内部数据集 = Wlc任意两列间转移条目.Wlc任意两列间转移条目_现成实用的双列.范_单列之内部数据集;





@Component({
    components: {
        Wlc任意两列间转移条目_单列,
        Wlc任意两列间转移条目_两列之间之竖栏_默认形态,
    },
})
export default class Wlc任意两列间转移条目_现成实用的双列 extends Vue {
    @Model('条目之分布已变动') public readonly 乙列所有条目之唯一标识之列表?: 范_条目之唯一标识之列表



    @Prop() public readonly 应全面禁止交互?: boolean

    @Prop() public readonly 甲列之称谓?: string
    @Prop() public readonly 乙列之称谓?: string
    @Prop() public readonly 甲列之特征样式类名之配置?: 范_界面元素之样式类名之配置
    @Prop() public readonly 乙列之特征样式类名之配置?: 范_界面元素之样式类名之配置

    @Prop() public readonly 按钮上的措辞_中央竖栏默认内容_将条目从甲列迁移至乙列?: string
    @Prop() public readonly 按钮上的措辞_中央竖栏默认内容_将条目从乙列迁移至甲列?: string
    @Prop() public readonly 按钮上的措辞_底部内容栏默认内容_将条目从甲列迁移至乙列?: string
    @Prop() public readonly 按钮上的措辞_底部内容栏默认内容_将条目从乙列迁移至甲列?: string
    @Prop() public readonly 各列均不应创建底部栏目?: boolean

    @Prop() public readonly 所有候选条目之列表?: 范_基础条目之列表
    @Prop() public readonly 单列允许列示的条目数之上限?: number
    @Prop() public readonly 各列新增条目之插入规则?: 范_各列新增条目之插入规则
    @Prop() public readonly 各列条目排序之函数?: 范_各列条目排序之函数

    @Prop() public readonly 甲列初始选中的条目之唯一标识之列表?: 范_条目之唯一标识之列表
    @Prop() public readonly 乙列初始选中的条目之唯一标识之列表?: 范_条目之唯一标识之列表
    @Prop() public readonly 甲列初始的用以过滤条目之配置?: string | RegExp
    @Prop() public readonly 乙列初始的用以过滤条目之配置?: string | RegExp

    @Prop() public readonly vue部件之定义_订制的主表条目?: null | 范_Vue动态部件之Is属性可接受的数据_但不可为部件名称字符串

    @Prop() public readonly 应在控制台输出详尽的调试信息?: boolean





    public 将甲列选中的条目迁移至乙列 (调用者?: Vue): void {
        // console.log('调用者', 调用者)
        this.将某列选中的条目迁移至对方列(this.甲列之数据集)
    }

    public 将乙列选中的条目迁移至甲列 (调用者?: Vue): void {
        // console.log('调用者', 调用者)
        this.将某列选中的条目迁移至对方列(this.乙列之数据集)
    }





    private 日志前缀: string = 'Vue 部件 <Wlc任意两列间转移条目_现成实用的双列> ：'

    private 所有条目之列表之去重后的缓存版本: null | 范_内用格式之条目之列表 = null

    private 甲列之数据集: 范_单列之内部数据集 = {
        所有条目之列表: [],
        当下选中的所有条目之唯一标识之列表: [],
        当下正在通过视觉强调动画引导用户: false,
    }

    private 乙列之数据集: 范_单列之内部数据集 = {
        所有条目之列表: [],
        当下选中的所有条目之唯一标识之列表: [],
        当下正在通过视觉强调动画引导用户: false,
    }

    private 将所有候选条目分配到左右两列_之期待: null | Promise<void> = null
    private 将所有候选条目分配到左右两列_之期待之原因: string = ''





    private get 甲列之称谓_最终采纳值 (): string {
        return 求可靠的文本(this.甲列之称谓, '未选择的条目', false)
        // return 求可靠的文本(this.甲列之称谓, '甲列', false)
    }

    private get 乙列之称谓_最终采纳值 (): string {
        return 求可靠的文本(this.乙列之称谓, '已选择的条目', false)
        // return 求可靠的文本(this.乙列之称谓, '乙列', false)
    }

    private get 用于各界面皿之状态集 (): 范_状态汇总数据 {
        const { 甲列之数据集, 乙列之数据集 } = this
        const 甲列当下选中的条目之总数 = 甲列之数据集.当下选中的所有条目之唯一标识之列表.length
        const 乙列当下选中的条目之总数 = 乙列之数据集.当下选中的所有条目之唯一标识之列表.length
        return {
            甲列当下选中的条目之总数,
            乙列当下选中的条目之总数,
            甲列当下没有条目拟迁移至乙列: 甲列当下选中的条目之总数 < 1,
            乙列当下没有条目拟迁移至甲列: 乙列当下选中的条目之总数 < 1,
        }
    }

    private get 按钮上的措辞_底部内容栏默认内容_将条目从甲列迁移至乙列_最终采纳值 (): string {
        return 求可靠的文本(this.按钮上的措辞_底部内容栏默认内容_将条目从甲列迁移至乙列, '◀', false)
    }

    private get 按钮上的措辞_底部内容栏默认内容_将条目从乙列迁移至甲列_最终采纳值 (): string {
        return 求可靠的文本(this.按钮上的措辞_底部内容栏默认内容_将条目从乙列迁移至甲列, '◀', false)
    }





    @Watch('所有候选条目之列表', { immediate: true })
    private 每当所有候选条目之列表变动后 (): void {
        this.将所有候选条目分配到左右两列('【所有候选条目之列表】变动了')
    }

    @Watch('乙列所有条目之唯一标识之列表', { immediate: true })
    private 每当乙列所有条目之唯一标识之列表变动后 (): void {
        this.将所有候选条目分配到左右两列('【乙列所有条目之唯一标识之列表】变动了')
    }





    private 接受外界给出的甲乙两列勾选条目之配置 (): void {
        const {
            日志前缀,
            应在控制台输出详尽的调试信息,
            甲列初始选中的条目之唯一标识之列表,
            乙列初始选中的条目之唯一标识之列表,
        } = this

        if (应在控制台输出详尽的调试信息) {
            console.debug(`${日志前缀} 甲列初始选中的条目之唯一标识之列表`, 甲列初始选中的条目之唯一标识之列表)
            console.debug(`${日志前缀} 乙列初始选中的条目之唯一标识之列表`, 乙列初始选中的条目之唯一标识之列表)
        }

        if (Array.isArray(甲列初始选中的条目之唯一标识之列表)) {
            this.甲列之数据集.当下选中的所有条目之唯一标识之列表 = 甲列初始选中的条目之唯一标识之列表
        }

        if (Array.isArray(乙列初始选中的条目之唯一标识之列表)) {
            this.乙列之数据集.当下选中的所有条目之唯一标识之列表 = 乙列初始选中的条目之唯一标识之列表
        }
    }

    private 将所有候选条目分配到左右两列 (本次原因: string = '不明原因'): Promise<void> {
        const { 日志前缀 } = this

        const _分配条目 = () => {
            const 本次为求稳妥应对候选条目去重: boolean = 本次原因 === '【所有候选条目之列表】变动了'
            const { 所有条目之列表之去重后的缓存版本 } = this
            const 本次应采用去重好的缓存版本: boolean = !本次为求稳妥应对候选条目去重 && Array.isArray(所有条目之列表之去重后的缓存版本) && 所有条目之列表之去重后的缓存版本.length > 0

            // console.debug(
            //     `${日志前缀}\n\t将所有候选条目分配到左右两列()。`,
            //     '\n\t本次原因：', 本次原因,
            //     '\n\t本次为求稳妥应对候选条目去重：', 本次为求稳妥应对候选条目去重,
            //     '\n\t本次应采用去重好的缓存版本：', 本次应采用去重好的缓存版本,
            //     '\n\t此时：',
            //     '\n\t\t乙列所有条目之列表：', this.乙列所有条目之唯一标识之列表 && [ ...this.乙列所有条目之唯一标识之列表 ]
            // )

            let 本次采用的所有候选条目之列表: 范_内用格式之条目之列表

            if (本次应采用去重好的缓存版本) {
                本次采用的所有候选条目之列表 = 所有条目之列表之去重后的缓存版本!
            } else {
                let 给出的所有候选条目之原始列表: 范_基础条目之列表

                if (Array.isArray(this.所有候选条目之列表)) {
                    给出的所有候选条目之原始列表 = this.所有候选条目之列表
                } else {
                    给出的所有候选条目之原始列表 = []
                }

                本次采用的所有候选条目之列表 = 给出的所有候选条目之原始列表.filter(基础条目 => !!基础条目 && typeof 基础条目 === 'object').map(基础条目 => {
                    const 内部实用条目: 范_内用格式之条目 = {
                        ...基础条目,

                        已禁止选择: !!基础条目.已禁止选择,
                        已选中: false,
                    }

                    return 内部实用条目
                })
            }

            const 所有候选条目之列表之去重好待缓存的版本: 范_内用格式之条目之列表 = []
            const 最终应位于甲列之条目之列表: 范_内用格式之条目之列表 = []
            const 最终应位于乙列之条目之列表: 范_内用格式之条目之列表 = []

            if (本次采用的所有候选条目之列表.length > 0) {
                const 乙列所有条目之唯一标识之列表_给出值 = this.乙列所有条目之唯一标识之列表
                let 乙列所有条目之唯一标识之列表_采纳值: 范_条目之唯一标识之列表

                if (Array.isArray(乙列所有条目之唯一标识之列表_给出值)) {
                    乙列所有条目之唯一标识之列表_采纳值 = 乙列所有条目之唯一标识之列表_给出值
                } else {
                    乙列所有条目之唯一标识之列表_采纳值 = []
                }

                const 一切条目之唯一标识之计数字典: { // 处于谨慎，防止数据源出现重复项。
                    [唯一标识: string]: number;
                } = {}

                本次采用的所有候选条目之列表.forEach(条目 => {
                    if (!条目) { return }

                    const {
                        唯一标识: 该条目之唯一标识,
                    } = 条目

                    if (本次为求稳妥应对候选条目去重) {
                        if (该条目之唯一标识 in 一切条目之唯一标识之计数字典) {
                            const 该条目之唯一标识之已遭遇次数 = 一切条目之唯一标识之计数字典[该条目之唯一标识]
                            一切条目之唯一标识之计数字典[该条目之唯一标识]++
                            const 出错提示之报文 = `${日志前缀} 发现唯一标识 “ ${该条目之唯一标识} ” 的第 ${该条目之唯一标识之已遭遇次数} 个重复的条目。`
                            console.error(出错提示之报文)
                            return
                        }

                        一切条目之唯一标识之计数字典[该条目之唯一标识] = 1
                        所有候选条目之列表之去重好待缓存的版本.push(条目)
                    }

                    const 该条目应位于乙列中: boolean = 乙列所有条目之唯一标识之列表_采纳值.includes(该条目之唯一标识)

                    if (该条目应位于乙列中) {
                        最终应位于乙列之条目之列表.push(条目)
                    } else {
                        最终应位于甲列之条目之列表.push(条目)
                    }
                })

                if (本次为求稳妥应对候选条目去重) {
                    const 所有重复出现过的唯一标识之列表 = Object.keys(一切条目之唯一标识之计数字典).filter(key => 一切条目之唯一标识之计数字典[key] > 1)
                    const 所有重复项之种类之总数 = 所有重复出现过的唯一标识之列表.length
                    if (所有重复项之种类之总数 > 0) {
                        const 异常唯一标识之总数 = 所有重复出现过的唯一标识之列表.reduce((总数, 条目之唯一标识) => {
                            return 总数 + 一切条目之唯一标识之计数字典[条目之唯一标识] - 1
                        }, 0)

                        const 出错提示之报文 = `${日志前缀} 总计有 ${所有重复项之种类之总数} 种候选条目出现重复项。重复条目累计 ${异常唯一标识之总数} 条。`
                        this.发布事件_已出错(出错提示之报文)
                    }

                    this.所有条目之列表之去重后的缓存版本 = 所有候选条目之列表之去重好待缓存的版本
                }
            }

            this.甲列之数据集.所有条目之列表 = 最终应位于甲列之条目之列表
            this.乙列之数据集.所有条目之列表 = 最终应位于乙列之条目之列表
        }

        if (!this.将所有候选条目分配到左右两列_之期待) {
            this.将所有候选条目分配到左右两列_之期待之原因 = 本次原因
            this.将所有候选条目分配到左右两列_之期待 = new Promise<void>((令期待落实, 令期待落空) => {
                _分配条目()
                this.$nextTick(() => {
                    令期待落实()
                    this.将所有候选条目分配到左右两列_之期待 = null
                    this.将所有候选条目分配到左右两列_之期待之原因 = ''
                })
            })
        } else {
            // console.debug(`${日志前缀}\n\t将所有候选条目分配到左右两列() 不执行。\n\t因仍在进行因`,
            //     this.将所有候选条目分配到左右两列_之期待之原因, '而起的任务。',
            //     '\n\t附本次原因：', 本次原因, '。'
            // )
        }

        return this.将所有候选条目分配到左右两列_之期待
    }

    private 将某列选中的条目迁移至对方列 (起列之数据集?: 范_单列之内部数据集): void {
        const { 甲列之数据集, 乙列之数据集 } = this

        let 迄列系乙列: boolean
        let 迄列之数据集: 范_单列之内部数据集

        if (起列之数据集 === 甲列之数据集) {
            迄列系乙列 = true
            迄列之数据集 = 乙列之数据集
        } else if (起列之数据集 === 乙列之数据集) {
            迄列系乙列 = false
            迄列之数据集 = 甲列之数据集
        } else {
            return
        }

        const 迁移结果 = 将某列选中的条目迁移至另一列(起列之数据集.所有条目之列表, 迄列之数据集.所有条目之列表)
        if (!迁移结果) { return }

        const {
            迁移后起列所有条目之列表,
            迁移后迄列所有条目之列表,
        } = 迁移结果

        const 迁移后乙列应具有的所有条目之列表: 范_内用格式之条目之列表 = 迄列系乙列 ? 迁移后迄列所有条目之列表 : 迁移后起列所有条目之列表
        const 乙列之条目之唯一标识之列表: 范_条目之唯一标识之列表 = 迁移后乙列应具有的所有条目之列表.map(条目 => 条目.唯一标识)
        this.发布事件_条目之分布已变动(乙列之条目之唯一标识之列表)
    }





    private 发布事件_条目之分布已变动 (应迁移至迄列之条目之唯一标识之列表: 范_条目之唯一标识之列表): void {
        const 事件之记载 = 应迁移至迄列之条目之唯一标识之列表
        // console.debug(this.日志前缀, '发布事件_条目之分布已变动', 事件之记载)
        this.$emit('条目之分布已变动', 事件之记载)
    }

    private 发布事件_已出错 (错误之记载或报文: Error | string): void {
        if (错误之记载或报文 instanceof Error) {
            console.error(错误之记载或报文)
            this.$emit('已出错', 错误之记载或报文)
        } else if (typeof 错误之记载或报文 === 'string') {
            const 出错提示之报文 = 错误之记载或报文.trim()
            console.error(出错提示之报文)
            this.$emit('已出错', new Error(出错提示之报文))
        }
    }





    private 每当点击用以将甲列选中之条目迁移至乙列之按钮后 (): void {
        this.将甲列选中的条目迁移至乙列()
    }

    private 每当点击用以将乙列选中之条目迁移至甲列之按钮后 (): void {
        this.将乙列选中的条目迁移至甲列()
    }

    // private 每当键盘按键松开时 (键盘事件之记载: KeyboardEvent): void {
    //     const { key } = 键盘事件之记载

    //     if (key === 'ArrowRight') {
    //         this.将甲列选中的条目迁移至乙列()
    //     } else if (key === 'ArrowLeft') {
    //         this.将乙列选中的条目迁移至甲列()
    //     }
    // }





    private mounted ():void {
        /**
         * https://v3.cn.vuejs.org/api/options-lifecycle-hooks.html#mounted
         *
         * ……注意 mounted 不会保证所有的子组件也都被挂载完成。
         * 如果你希望等待整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick：……
         *
         * 奇怪的是，即便当初下方源代码并未采用 $nextTick 以延后初始化动作，
         * 在直接采用 TypeScript 语言的示范中项目照样总是不会遭遇错误现象；
         * 但在采用 JavaScript 语言的示范项目中则总是会遭遇错误。该错误之现象如下：
         *     - 甲列的初始勾选的条目总是正常、符合预期；
         *     - 乙列的初始勾选的条目总是为零条，这不符合预期。
         */
        this.$nextTick().then(this.接受外界给出的甲乙两列勾选条目之配置)
    }
}
</script>









<style lang="stylus">
// 在多个 Vue 部件（ component ）中均加载某 .styl 文件时，
// 即便采用 @require 语句而非 @import 语句，也无法避免该 .styl 文件之内容
// 编译出的 css 内容重复出现在最终的 .css 文件中。即，这些 css 内容会反复出现！
// 即使变通地采用 stylus 全局变量和 if 语句来包裹 @import 或 @require 语句仍无济于事。
// 故，各 Vue 部件均依赖的 .styl 文件（目前仅《 `0-基础.styl` 》）的加载语句，
// 既不应写在本 <style> 代码块内，也不应写在各 Vue 部件专属的 .styl 文件中。
// 否则，非但 css 会有重复内容，且重复加载的 css 内容其相对于其他 css 内容之顺序也不能确保正确。
// 目前推荐的做法是，始终提醒本工具之使用者在 Vue 的 `main.ts` 或 `main.js` 中加载**两**个 `0-基础.styl` 文件。

@import '../stylus/仅尺寸与排版与关键行为/默认/2-现成实用的双列.styl'
@import '../stylus/仅着色与装饰/默认/2-现成实用的双列.styl'
</style>
